name: main
on:
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets exist
        env:
          VARS_JSON: ${{ secrets.VARS_JSON }}
          SERVICE_ACCOUNT: ${{ secrets.SERVICE_ACCOUNT }}
        run: |
          for s in VARS_JSON SERVICE_ACCOUNT; do
            if [ -z "${!s}" ]; then
              echo "Error: Missing required secret: $s"
              exit 1
            fi
          done
          echo "All required secrets exist"
      - name: Validate VARS_JSON schema
        env:
          VARS: ${{ secrets.VARS_JSON }}
        run: |
          jq -e '
            (.aws_access_key_id     | type=="string") and
            (.aws_secret_access_key | type=="string") and
            (.aws_region            | type=="string") and
            (.cf_token              | type=="string") and
            (.uptimerobot_token     | type=="string") and
            (.admin_ip              | type=="string") and
            (.project_name          | type=="string") and
            (.instance_type         | type=="string") and
            (.instance_disk_size    | type=="string") and
            (.sites | type=="object") and
            (
              (.sites | length) == 0 or
              (all(.sites[]; (type=="object") and (.domain | type=="string") and (.monitor_keyworkd | type=="string")))
            )
          ' <<<"$VARS" >/dev/null || { echo "Error: VARS_JSON schema invalid"; exit 1; }
          echo "VARS_JSON schema valid"
      - name: Validate SERVICE_ACCOUNT schema
        env:
          SA: ${{ secrets.SERVICE_ACCOUNT }}
        run: |
          jq -e '
            (.aws_access_key_id | type=="string") and
            (.aws_secret_access_key | type=="string") and
            (.aws_region | type=="string")
          ' <<<"$SA" >/dev/null || { echo "Error: SERVICE_ACCOUNT schema invalid"; exit 1; }
          echo "SERVICE_ACCOUNT schema valid"

  prepare-tfbackend:
    runs-on: ubuntu-latest
    needs: validate-secrets
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_region }}
      - name: Creates / Checks state bucket
        env:
          BUCKET_NAME: ${{ fromJson(secrets.VARS_JSON).project_name }}-bucket-tfstate
          AWS_REGION: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_region }}
        run: |
          set -euo pipefail
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Bucket already exists: $BUCKET_NAME"
          else
            echo "Bucket does not exist. Creating: $BUCKET_NAME"
            aws s3api create-bucket --bucket "$BUCKET_NAME" \
              --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION"
            echo "Applying public access block to $BUCKET_NAME"
            aws s3api put-public-access-block --bucket "$BUCKET_NAME" --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
            echo "Enabling versioning for $BUCKET_NAME"
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            echo "Enabling default encryption (SSE-S3) for $BUCKET_NAME"
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          fi
      - name: Creates / Checks state table
        env:
          TABLE_NAME: ${{ fromJson(secrets.VARS_JSON).project_name }}-table-tfstate
        run: |
          set -euo pipefail
          if aws dynamodb describe-table --table-name "$TABLE_NAME" >/dev/null 2>&1; then
            echo "DynamoDB table '$TABLE_NAME' already exists, skipping."
          else
            echo "DynamoDB table '$TABLE_NAME' does not exist, creating it."
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              >/dev/null
            echo "Waiting for DynamoDB table '$TABLE_NAME' to become ACTIVE."
            aws dynamodb wait table-exists --table-name "$TABLE_NAME" >/dev/null
            echo "DynamoDB table '$TABLE_NAME' created and ACTIVE."
          fi
      - name: Create TF Backend (jq -> backend.tf.json)
        env:
          BUCKET_NAME: ${{ fromJson(secrets.VARS_JSON).project_name }}-bucket-tfstate
          TABLE_NAME: ${{ fromJson(secrets.VARS_JSON).project_name }}-table-tfstate
          AWS_REGION: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_region }}
        run: |
          tee backend.tf > /dev/null <<EOF
          terraform {
            backend "s3" {
              bucket = "$BUCKET_NAME"
              key    = "terraform.tfstate"
              dynamodb_table = "$TABLE_NAME"
              region = "$AWS_REGION"
              encrypt = true
            }
          }
          EOF
          echo "backend.tf created"
      - name: Upload backend.tf
        uses: actions/upload-artifact@v4
        with:
          name: tfbackend
          path: backend.tf

  prepare-tfvars:
    runs-on: ubuntu-latest
    needs: validate-secrets
    steps:
      - name: Generate terraform.auto.tfvars.json
        env:
          VARS: ${{ secrets.VARS_JSON }}
        run: |
          echo "Storing keys into terraform.auto.tfvars.json:"
          echo "$VARS" | jq -r 'keys[]' | sed "s/^/ - /"
          printf '%s\n' "$VARS" > terraform.auto.tfvars.json
      - name: Upload terraform.auto.tfvars.json
        uses: actions/upload-artifact@v4
        with:
          name: tfvars
          path: terraform.auto.tfvars.json

  prepare-artifacts:
    runs-on: ubuntu-latest
    env:
      BUILD_DIR: build
      BUILD_LAMBDA_DIR: build/lambda
      BUILD_ANSIBLE_DIR: build/ansible
      ARTIFACTS_DIR: artifacts
      ARTIFACTS_LAMBDA_DIR: artifacts/lambda
      ARTIFACTS_ANSIBLE_DIR: artifacts/ansible
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Cache python lambda build
        id: cache-python
        uses: actions/cache@v4
        with:
          path: ${{ env.BUILD_LAMBDA_DIR }}/**/packages
          key: ${{ runner.os }}-lambda-py-${{ hashFiles('build/lambda/**') }}
          restore-keys: |
            ${{ runner.os }}-lambda-py-
      - name: Cache node lambda build
        id: cache-node
        uses: actions/cache@v4
        with:
          path: ${{ env.BUILD_LAMBDA_DIR }}/**/node_modules
          key: ${{ runner.os }}-lambda-node-${{ hashFiles('build/lambda/**') }}
          restore-keys: |
            ${{ runner.os }}-lambda-node-
      - name: Create artifacts folders
        run: |
          mkdir -p "$ARTIFACTS_LAMBDA_DIR"
          mkdir -p "$ARTIFACTS_ANSIBLE_DIR"
      - name: Build python lambdas (cache-aware)
        if: steps.cache-python.outputs.cache-hit != 'true'
        run: |
          found=0
          for d in "$BUILD_LAMBDA_DIR"/*; do
            if [[ -f "$d/requirements.txt" ]]; then
              found=1
              echo "Building python lambda $(basename "$d")"
              mkdir -p "$d/packages"
              python -m pip install -r "$d/requirements.txt" -t "$d/packages"
            fi
          done
          if [[ "$found" -eq 0 ]]; then
            echo "No requirements.txt found in $BUILD_LAMBDA_DIR/*; skipping python build."
          fi
      - name: Build node lambdas (cache-aware)
        if: steps.cache-node.outputs.cache-hit != 'true'
        run: |
          found=0
          for d in "$BUILD_LAMBDA_DIR"/*; do
            if [[ -f "$d/package.json" ]]; then
              found=1
              echo "Building node lambda $(basename "$d")"
              (cd "$d" && npm ci --omit=dev)
            fi
          done
          if [[ "$found" -eq 0 ]]; then
            echo "No package.json found in $BUILD_LAMBDA_DIR/*; skipping node build."
          fi
      - name: Cache lambda zip artifacts
        id: cache-lambda-zips
        uses: actions/cache@v4
        with:
          path: ${{ env.ARTIFACTS_LAMBDA_DIR }}
          key: ${{ runner.os }}-lambda-zips-${{ hashFiles('build/lambda/**') }}
          restore-keys: |
            ${{ runner.os }}-lambda-zips-
      - name: Cache ansible zip artifacts
        id: cache-ansible-zips
        uses: actions/cache@v4
        with:
          path: ${{ env.ARTIFACTS_ANSIBLE_DIR }}
          key: ${{ runner.os }}-ansible-zips-${{ hashFiles('build/ansible/**') }}
          restore-keys: |
            ${{ runner.os }}-ansible-zips-
      - name: Zip lambdas
        if: steps.cache-lambda-zips.outputs.cache-hit != 'true'
        run: |
          for d in "$BUILD_LAMBDA_DIR"/*; do
            name="$(basename "$d")"
            echo "Zipping lambda $name"
            (cd "$d" && zip -r "$GITHUB_WORKSPACE/$ARTIFACTS_LAMBDA_DIR/$name.zip" .)
          done
      - name: Zip ansible
        if: steps.cache-ansible-zips.outputs.cache-hit != 'true'
        run: |
          for d in "$BUILD_ANSIBLE_DIR"/*; do
            name="$(basename "$d")"
            echo "Zipping ansible $name"
            (cd "$d" && zip -r "$GITHUB_WORKSPACE/$ARTIFACTS_ANSIBLE_DIR/$name.zip" .)
          done
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts
          path: artifacts

  tf-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      - prepare-tfbackend
      - prepare-tfvars
      - prepare-artifacts
    env:
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_region }}
      - name: Download tfbackend
        uses: actions/download-artifact@v4
        with:
          name: tfbackend
          path: .
      - name: Download tfvars
        uses: actions/download-artifact@v4
        with:
          name: tfvars
          path: .
      - name: Create plugin cache dir
        run: mkdir -p "${TF_PLUGIN_CACHE_DIR}"
      - name: Cache terraform
        uses: actions/cache@v4
        with:
          path: |
            .terraform
            ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-tfinit-${{ hashFiles('**/*.tf', '.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-tfinit-
      - name: Terraform init
        run: terraform init -input=false
      - name: Terraform plan
        run: terraform plan -input=false -no-color -out=tfplan
      - name: Generate visual plan
        run: terraform show -no-color tfplan > tfplan_visual
      - name: Upload tfplan_visual
        uses: actions/upload-artifact@v4
        with:
          name: tfplan_visual
          path: tfplan_visual
      - name: Upload tfplan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: tfplan

  approbal:
    runs-on: ubuntu-latest
    needs: tf-plan
    steps:
      - name: Download tfplan_visual
        uses: actions/download-artifact@v4
        with:
          name: tfplan_visual
          path: .
      - name: Await Manual Approval
        timeout-minutes: 5
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          minimum-approvals: 1
          approvers: ${{ github.actor }}
          issue-title: "Manual Approval Required for Terraform Apply"
          issue-body-file-path: tfplan_visual

  tf-apply:
    runs-on: ubuntu-latest
    needs:
      - approbal
    env:
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SERVICE_ACCOUNT).aws_region }}
      - name: Install Ansible
        run: sudo apt-get install -y ansible
      - name: Download tfplan
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: .
      - name: Download tfbackend
        uses: actions/download-artifact@v4
        with:
          name: tfbackend
          path: .
      - name: Download tfvars
        uses: actions/download-artifact@v4
        with:
          name: tfvars
          path: .
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: artifacts
          path: .
      - name: Set execute permissions for scripts
        run: |
          if [ -d "./scripts" ]; then
            chmod +x ./scripts/*.sh || true
            ls -l ./scripts
          else
            echo "Directory ./scripts does not exist"
            exit 1
          fi
      - name: Create plugin cache dir
        run: mkdir -p "${TF_PLUGIN_CACHE_DIR}"
      - name: Cache terraform
        uses: actions/cache@v4
        with:
          path: |
            .terraform
            ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-tfinit-${{ hashFiles('**/*.tf', '.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-tfinit-

      - name: Inspect artifacts folder
        shell: bash
        run: |
          set -euo pipefail

          echo "Workspace: $GITHUB_WORKSPACE"
          echo ""
          echo "Top-level files/directories:"
          ls -la

          echo ""
          echo "Find any 'artifacts' directory (in case it was nested):"
          find . -maxdepth 5 -type d -name artifacts -print

          echo ""
          if [ ! -d "./artifacts" ]; then
            echo "ERROR: ./artifacts directory not found"
            echo "Showing all directories (max depth 4):"
            find . -maxdepth 4 -type d -print
            exit 1
          fi

          echo ""
          echo "Tree of ./artifacts:"
          if command -v tree >/dev/null 2>&1; then
            tree -a ./artifacts
          else
            sudo apt-get update -y
            sudo apt-get install -y tree
            tree -a ./artifacts
          fi

          echo ""
          echo "Files with sizes (sorted):"
          find ./artifacts -type f -printf '%10s  %p\n' | sort -n

          echo ""
          echo "Permissions (directories):"
          find ./artifacts -type d -exec ls -ld {} \;

          echo ""
          echo "Permissions (files):"
          find ./artifacts -type f -exec ls -l {} \;


      - name: Terraform init
        run: terraform init -input=false
      - name: Terraform apply
        run: terraform apply -auto-approve tfplan
