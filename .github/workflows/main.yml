name: main
on:
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:

  check-repo-structure:
    runs-on: ubuntu-latest
    env:
      REQUIRED_FILES: bootstrap.sh data.tf locals.tf main.tf providers.tf secrets.tf variables.tf README.md .terraform.lock.hcl
      REQUIRED_FOLDERS: src scripts
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
      - name: Files check
        shell: bash
        run: |
          for f in $REQUIRED_FILES; do
            test -f "$f" || { echo "::error title=Missing file::$f"; exit 1; }
          done
      - name: Folders check
        shell: bash
        run: |
          for d in $REQUIRED_FOLDERS; do
            test -d "$d" || { echo "::error title=Missing directory::$d does not exist"; exit 1; }
          done

  check-schemas:
    runs-on: ubuntu-latest
    env:
      SA_JSON: ${{ secrets.SA_JSON }}
      SECRETS_JSON: ${{ secrets.SECRETS_JSON }}
      VARS_JSON: ${{ vars.VARS_JSON }}
      SA_FILE: "sa.json"
      VARS_FILE: "vars.json"
      SECRETS_FILE: "secrets.json"
      SCHEMA_DIR: "./.github/schemas"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
      - name: Save SA_JSON as file
        run: printf '%s' "$SA_JSON" > "$SA_FILE"
      - name: Save VARS_JSON as file
        run: printf '%s' "$VARS_JSON" > "$VARS_FILE"
      - name: Save SECRETS_JSON as file
        run: printf '%s' "$SECRETS_JSON" > "$SECRETS_FILE"
      - name: Validate SA_JSON
        uses: GrantBirki/json-yaml-validate@v4.0.0
        with:
          json_schema: "${{ env.SCHEMA_DIR }}/${{ env.SA_FILE }}"
          files: ${{ env.SA_FILE }}
          comment: "true"
      - name: Validate VARS_JSON
        uses: GrantBirki/json-yaml-validate@v4.0.0
        with:
          json_schema: "${{ env.SCHEMA_DIR }}/${{ env.VARS_FILE }}"
          files: ${{ env.VARS_FILE }}
          comment: "true"
      - name: Validate SECRETS_JSON
        uses: GrantBirki/json-yaml-validate@v4.0.0
        with:
          json_schema: "${{ env.SCHEMA_DIR }}/${{ env.SECRETS_FILE }}"
          files: ${{ env.SECRETS_FILE }}
          comment: "true"

  check-aws-credentials:
    runs-on: ubuntu-latest
    needs:
      - check-schemas
    env:
      SA_JSON: ${{ secrets.SA_JSON }}
      ARN_ADMINISTRATOR: arn:aws:iam::aws:policy/AdministratorAccess
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SA_JSON).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SA_JSON).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SA_JSON).aws_region }}
      - name: Check user is valid (STS)
        run: |
          if aws sts get-caller-identity >/dev/null 2>&1; then
            echo "OK: credentials are valid"
          else
            echo "ERROR: invalid AWS credentials (sts get-caller-identity failed)"
            exit 1
          fi
      - name: Get User policy ARN
        id: arn-user
        run: |
          ARN="$(aws sts get-caller-identity --query Arn --output text)"
          echo "arn_user=$ARN" >> "$GITHUB_OUTPUT"
      - name: Check attached managed policy is AdministratorAccess
        env:
          ARN_USER: ${{ steps.arn-user.outputs.arn_user }}
        run: |
          COUNT="$(aws iam list-attached-user-policies \
            --user-name "${ARN_USER##*/}" \
            --query "AttachedPolicies[?PolicyArn=='${ARN_ADMINISTRATOR}'] | length(@)" \
            --output text)"
          if [[ "$COUNT" = "1" ]]; then
            echo "OK: user has AdministratorAccess attached"
          else
            echo "ERROR: user does NOT have AdministratorAccess attached"
            exit 1
          fi

  generate-tf-vars:
    runs-on: ubuntu-latest
    needs:
    - check-schemas
    env:
      VARS_JSON: ${{ vars.VARS_JSON }}
    steps:
      - name: Generate tf_vars.json
        run: |
          echo "Storing keys into tf_vars.json:"
          echo "$VARS_JSON" | jq -r 'keys[]' | sed "s/^/ - /"
          printf '%s\n' "$VARS_JSON" > tf_vars.json
      - name: Upload tf_vars.json
        uses: actions/upload-artifact@v4
        with:
          name: tf_vars.json
          path: tf_vars.json

  generate-tf-secrets:
    runs-on: ubuntu-latest
    needs:
      - check-schemas
    env:
      SECRETS_JSON: ${{ secrets.SECRETS_JSON }}
    steps:
      - name: Generate tf_secrets.json
        run: |
          echo "Storing keys into tf_secrets.json:"
          echo "$SECRETS_JSON" | jq -r 'keys[]' | sed "s/^/ - /"
          printf '%s\n' "$SECRETS_JSON" > tf_secrets.json
      - name: Upload tf_secrets.json
        uses: actions/upload-artifact@v4
        with:
          name: tf_secrets.json
          path: tf_secrets.json

  generate-tf-backend:
    runs-on: ubuntu-latest
    needs:
      - check-aws-credentials
      - generate-tf-vars
    env:
      BUCKET_NAME: ${{ fromJson(vars.VARS_JSON).project_name }}-bucket-tfstate
      AWS_REGION: ${{ fromJson(secrets.SA_JSON).aws_region }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SA_JSON).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SA_JSON).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SA_JSON).aws_region }}
      - name: Creates / Checks state bucket
        run: |
          set -euo pipefail
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Bucket already exists: $BUCKET_NAME"
          else
            echo "Bucket does not exist. Creating: $BUCKET_NAME"
            aws s3api create-bucket --bucket "$BUCKET_NAME" \
              --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION"
            echo "Applying public access block to $BUCKET_NAME"
            aws s3api put-public-access-block --bucket "$BUCKET_NAME" --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
            echo "Enabling versioning for $BUCKET_NAME"
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            echo "Enabling default encryption (SSE-S3) for $BUCKET_NAME"
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
          fi
      - name: Create tf_backend.tf
        run: |
          tee tf_backend.tf > /dev/null <<EOF
          terraform {
            backend "s3" {
              bucket       = "$BUCKET_NAME"
              key          = "terraform.tfstate"
              use_lockfile = true
              region       = "$AWS_REGION"
              encrypt      = true
            }
          }
          EOF
          echo "tf_backend.tf created"
      - name: Upload tf_backend.tf
        uses: actions/upload-artifact@v4
        with:
          name: tf_backend.tf
          path: tf_backend.tf

  tf-plan:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      - check-repo-structure
      - check-aws-credentials
      - generate-tf-vars
      - generate-tf-secrets
      - generate-tf-backend
    env:
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
      MODULES_DIR: ./modules
      PACKAGES_DIR: ./src
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
      - name: Create plugin cache dir
        run: mkdir -p "${TF_PLUGIN_CACHE_DIR}"
      - name: Terraform version
        run: terraform version
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SA_JSON).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SA_JSON).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SA_JSON).aws_region }}
      - name: Download tf_backend.tf
        uses: actions/download-artifact@v4
        with:
          name: tf_backend.tf
          path: ""
      - name: Download tf_vars
        uses: actions/download-artifact@v4
        with:
          name: tf_vars.json
          path: ""
      - name: Download tf_secrets
        uses: actions/download-artifact@v4
        with:
          name: tf_secrets.json
          path: ""
      - name: Cache Terraform providers
        id: tfinit-providers
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-tfinit-providers-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-tfproviders-
      - name: Terraform init
        run: terraform init -input=false -lockfile=readonly
      - name: Fail if lockfile changed
        run: |
          git diff --exit-code .terraform.lock.hcl
      - name: Terraform plan
        run: terraform plan -input=false -no-color -out=tf_plan.out -var-file="tf_secrets.json" -var-file="tf_vars.json"
      - name: Generate visual plan
        run: terraform show -no-color tf_plan.out > tfplan_visual
      - name: Upload tfplan_visual
        uses: actions/upload-artifact@v4
        with:
          name: tfplan_visual
          path: tfplan_visual
      - name: Upload tf_plan.out
        uses: actions/upload-artifact@v4
        with:
          name: tf_plan.out
          path: tf_plan.out

  approbal:
    runs-on: ubuntu-latest
    needs: tf-plan
    steps:
      - name: Download tfplan_visual
        uses: actions/download-artifact@v4
        with:
          name: tfplan_visual
          path: .
      - name: Await Manual Approval
        timeout-minutes: 5
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          minimum-approvals: 1
          approvers: ${{ github.actor }}
          issue-title: "Manual Approval Required for Terraform Apply"
          issue-body-file-path: tfplan_visual

  tf-apply:
    runs-on: ubuntu-latest
    needs:
      - approbal
    env:
      TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
      PACKAGES_DIR: "./src"
      SCRIPTS_DIR: "./scripts"
      MODULES_DIR: "./modules"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
      - name: Create tf providers dir
        run: mkdir -p "${TF_PLUGIN_CACHE_DIR}"
      - name: Create modules dir
        run: mkdir -p "${MODULES_DIR}"
      - name: Remove src content
        run: rm -rf "${PACKAGES_DIR}/*"
      - name: Create src dir
        run: mkdir -p "${PACKAGES_DIR}"
      - name: Set execute permissions for scripts
        run: |
          if [ -d $SCRIPTS_DIR ]; then
            chmod +x $SCRIPTS_DIR/*.sh || true
            ls -l $SCRIPTS_DIR
          else
            echo "Directory $SCRIPTS_DIR does not exist"
            exit 1
          fi
      - name: Terraform version
        run: terraform version
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJson(secrets.SA_JSON).aws_access_key_id }}
          aws-secret-access-key: ${{ fromJson(secrets.SA_JSON).aws_secret_access_key }}
          aws-region: ${{ fromJson(secrets.SA_JSON).aws_region }}
      - name: Install Ansible
        run: sudo apt-get update && sudo apt-get install -y ansible
      - name: Download tf_backend.tf
        uses: actions/download-artifact@v4
        with:
          name: tf_backend.tf
          path: ""
      - name: Download tf_plan.out
        uses: actions/download-artifact@v4
        with:
          name: tf_plan.out
          path: ""
      - name: Cache Terraform providers (plugin cache)
        id: tfinit-providers
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: ${{ runner.os }}-tfinit-providers-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-tfinit-providers-
      - name: Terraform init
        run: terraform init -input=false -lockfile=readonly
      - name: Fail if lockfile changed
        run: |
          git diff --exit-code .terraform.lock.hcl
      - name: Terraform apply
        run: terraform apply -auto-approve tf_plan.out
